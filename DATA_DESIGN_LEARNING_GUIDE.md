# データ設計 学習ガイド - 理解を深めるための実践練習（RDB中心）

## 📋 理解度チェックリスト

以下の質問に自分で答えられるか確認してください。答えられない場合は、その部分を重点的に学習しましょう。

### 基礎編（モデリングの土台）

1. **データ設計とは何を決める作業か？**
   - 「業務のルール」を「データの形」に落とすとはどういう意味か？
   - 画面/帳票/API都合の“見た目”と、永続データ（真実の源泉）の違いは？

2. **エンティティ・属性・関係（ERの基本）**
   - エンティティ（名詞）をどう見つけるか？
   - 1対多 / 多対多 / 1対1 の判断基準は？
   - 多対多はなぜ中間テーブルが必要か？

3. **キーの設計**
   - 主キー（PK）と代替キー（UK）の役割は？
   - 自然キー vs サロゲートキー（連番ID）のトレードオフは？
   - 外部キー（FK）で何が守れるか？

4. **正規化と冗長性**
   - 1NF/2NF/3NF の目的は何か？
   - 「更新異常（追加/更新/削除）」を例で説明できるか？
   - どこまで正規化し、どこから非正規化するかの判断軸は？

5. **NULLの扱い**
   - NULLは「値がない」以外に「不明」も表すが、設計上どう扱うべきか？
   - NULLを許す/許さないは何で決めるか？

### 応用編（運用・性能・変更に耐える）

6. **制約（Constraints）**
   - NOT NULL / CHECK / UNIQUE / FK の違いと使い分けは？
   - アプリのバリデーションとDB制約の役割分担は？

7. **インデックス設計**
   - インデックスが速くなる理由と、遅くなる場面（更新コスト）は？
   - 複合インデックスの列順をどう決めるか？
   - “検索条件 + 並び替え” を意識しているか？

8. **トランザクションと整合性**
   - ACIDを説明できるか？
   - 分離レベル（READ COMMITTED等）で何が起きるか？
   - 競合（ロストアップデート等）をどう防ぐか（楽観/悲観）？

9. **履歴・論理削除・監査**
   - 論理削除（`deleted_at`）を採用する理由と落とし穴は？
   - 更新履歴（監査ログ）をどの粒度で残すか？

10. **変更に強い設計**
   - “仕様変更が起きる場所”を予測して分離できているか？
   - マイグレーション運用（後方互換、段階リリース）を想像できるか？

---

## 🎯 段階的練習課題

### レベル1: 小さなドメインを正確に表す（基本）

#### 課題1-1: ユーザー登録のデータ設計
**目標**: ありがちな機能を「制約まで含めて」設計する

- 要件（例）:
  - ユーザーは `email` で一意
  - 表示名（ニックネーム）は任意
  - パスワードは平文保存禁止（※保存するのはハッシュ）
  - 登録日時/更新日時を保持

**やること**:
- テーブル一覧（エンティティ候補）を出す
- 各カラムの型・NOT NULL・UNIQUE を決める
- PK方式（連番/UUIDなど）を決め、理由を書けるようにする

**チェックポイント**:
- DB制約で守るべきルールが入っているか？
- 将来の拡張（メール変更、退会）を考えられているか？

#### 課題1-2: 住所の扱い（1対多）
- 要件（例）:
  - ユーザーは複数住所を持てる（配送先/請求先など）
  - “デフォルト住所”の概念がある

**チェックポイント**:
- 住所はユーザーの子（1対多）として表現できているか？
- デフォルトの一意性をどう保証するか（設計案を2つ出す）？

---

### レベル2: 多対多と中間テーブル（頻出）

#### 課題2-1: 記事とタグ（多対多）
**要件（例）**:
- 記事は複数タグを持つ
- タグは複数記事に付く
- 同じタグを同じ記事に二重付与できない

**やること**:
- `articles`, `tags`, `article_tags`（中間）を設計
- `article_tags` に必要な制約（複合UNIQUE等）を決める

**チェックポイント**:
- 多対多を「中間テーブル + 制約」で表現できているか？

---

### レベル3: 正規化と“更新異常”の実感

#### 課題3-1: 注文（注文ヘッダ/注文明細）
**要件（例）**:
- 注文には複数商品が入る
- 注文時点の「単価」を固定したい（後で商品価格が変わっても注文は変わらない）

**やること**:
- `orders`（ヘッダ）と `order_items`（明細）に分ける
- どの属性がどちらに属するか、理由を言語化する

**チェックポイント**:
- “注文時点価格”をどこに持つべきか説明できるか？
- 3NFに近づけた設計になっているか？

#### 課題3-2: 反例を作る（わざと悪い設計）
- 注文テーブル1枚に全部詰め込む案を作り、どんな更新異常が起きるか列挙する

---

### レベル4: 制約・整合性・削除の扱い

#### 課題4-1: 参照整合性（FK）と削除戦略
**要件（例）**:
- ユーザー削除時、注文は残す（監査/法的要件）
- 商品削除時、過去注文明細は残す

**やること**:
- 物理削除/論理削除のどちらを採用するか決める
- `ON DELETE` の戦略（RESTRICT/CASCADE/SET NULL）を検討し、理由を書く

**チェックポイント**:
- “残すべき事実”を消さない設計になっているか？

#### 課題4-2: 監査カラムの標準化
- 全テーブルに持たせるべきカラム（例: `created_at`, `updated_at`, `created_by` …）を整理する

---

### レベル5: インデックスとクエリを意識した設計

#### 課題5-1: よくある検索を列挙してインデックスを決める
**要件（例）**:
- 注文一覧: `user_id` + `created_at desc`
- 注文検索: 期間 + ステータス + キーワード（任意）

**やること**:
- “想定クエリ”を文章で5本以上書く
- それに対するインデックス案（単一/複合）を作る

**チェックポイント**:
- 更新頻度とのバランスを考えられているか？
- ソート列を含む複合インデックスの列順を説明できるか？

---

### レベル6: 変更に強い設計（実務寄り）

#### 課題6-1: ステータス設計
**要件（例）**:
- 注文ステータス: NEW → PAID → SHIPPED → DELIVERED（+ CANCELLED）

**やること**:
- 文字列/整数/マスタテーブル どれで持つか決める
- 将来ステータス追加・文言変更・多言語化を考えた設計にする

#### 課題6-2: “後から入る要件”を吸収する
**例**:
- クーポン、ポイント、複数税率、返品、分割発送 など

**やること**:
- どのテーブルが肥大化しそうか予測して、分離案を出す
- マイグレーションで安全に移行する手順（ざっくりでOK）を書く

---

## 📚 学習の進め方

### ステップ1: まず要件を「名詞」と「ルール」に分解する
- 名詞: エンティティ候補
- ルール: 制約候補（UNIQUE / FK / CHECK / NOT NULL）

### ステップ2: ER図（テーブルと関係）を先に描く
- 先にカラムを詰めすぎない
- 関係（カードinality）を確定する

### ステップ3: 正規化で“更新異常”を潰す
- まずは3NFを目標
- その後、必要なら非正規化（理由を書けることが条件）

### ステップ4: 想定クエリを文章で書く
- 一覧、詳細、検索、集計（件数/売上）を最低1本ずつ

### ステップ5: 制約とインデックスで守りを固める
- DB制約で壊れないようにする
- インデックスで遅くならないようにする（必要最低限）

---

## ✅ 理解度の確認方法

以下ができれば、データ設計が“設計”になっています：

1. **要件→制約に落とせる**
   - 「一意」「必須」「依存」「履歴」などをDB制約に落とし込める

2. **変更に耐える説明ができる**
   - “なぜそのキー/その分離/その型” かを言語化できる

3. **削除と履歴が破綻しない**
   - 物理削除/論理削除、監査ログ、FK戦略が整合している

4. **想定クエリとインデックスが整合する**
   - 検索条件・並び替え・JOINを想定してインデックスを説明できる

---

## 🎓 次のステップ

このガイドのレベル5〜6まで進めたら：

1. **実DBで検証する**
   - SQLite / PostgreSQL / MySQL いずれかで実際にDDLを書いてみる
   - `EXPLAIN` でクエリプランを読む

2. **マイグレーション運用を練習する**
   - カラム追加→バックフィル→制約追加 の段階リリースを体験する

3. **アプリ設計と接続する**
   - Entity/DTOの分離、バリデーション層、トランザクション境界を意識する

---

## 💡 よくある落とし穴

- **“画面に必要な項目”をそのまま1テーブルに詰める**: 更新異常・NULLだらけ・拡張不能になりがち
- **FKを張らない**: データが壊れても気づけない（後で直せない）
- **論理削除のWHERE漏れ**: 一覧/集計が崩れる（設計・実装どちらでも対策が必要）
- **インデックス貼りすぎ**: 書き込みが遅くなる（本当に必要なものだけ）

---

焦らず、「要件→モデル→制約→クエリ→運用」の順で繰り返すと、実務でも通用するデータ設計力がつきます。

