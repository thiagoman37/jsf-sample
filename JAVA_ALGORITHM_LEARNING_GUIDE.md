# Javaで学ぶアルゴリズム学習ガイド - 理解を深めるための実践練習

## 📋 理解度チェックリスト

以下の質問に自分で答えられるか確認してください。答えられない場合は、その部分を重点的に学習しましょう。

### 基礎編（アルゴリズムの共通語彙）

1. **計算量（Big-O）の意味は？**
   - \(O(1), O(\log n), O(n), O(n\log n), O(n^2)\) を直感的に説明できるか？
   - 「最悪計算量」「平均計算量」「償却計算量（amortized）」の違いは？

2. **メモリ（空間計算量）を意識できているか？**
   - 配列と連結リストのメモリの違いは？
   - 参照（reference）と値（primitive）の違いは？

3. **不変条件（ループ不変条件）で正しさを説明できるか？**
   - 二分探索・挿入ソートの不変条件を言葉で言えるか？

4. **境界条件（edge case）を列挙できるか？**
   - 空、1要素、重複、負数、巨大入力、オーバーフロー、null、ソート済み/逆順など

5. **再帰が何をしているか説明できるか？**
   - ベースケースと再帰ステップの役割は？
   - スタックオーバーフローが起きる理由は？

### 応用編（典型パターン）

6. **探索の基本**
   - 線形探索と二分探索の違い、使い分けは？
   - 二分探索の「条件の単調性」とは？

7. **ソートの基本**
   - 安定ソート/不安定ソートの違いは？
   - 比較ソートの下限（\(\Omega(n\log n)\)）を説明できるか？

8. **データ構造の基本**
   - Stack/Queue/Deque/Heap/HashMap/TreeMap の用途と計算量は？
   - HashMapの衝突と負荷率（load factor）を理解しているか？

9. **設計パターン（解法の型）**
   - Two Pointers / Sliding Window / Prefix Sum / Hash / BFS/DFS / DP / Greedy の典型問題を言えるか？

10. **Java特有の落とし穴**
   - `int` のオーバーフロー（`long`が必要な場面）を挙げられるか？
   - `Arrays.sort(int[])` と `Arrays.sort(Integer[])` の違いは？
   - 文字列結合で `StringBuilder` が必要な場面は？

---

## 🎯 段階的練習課題（Javaで手を動かす）

### レベル0: 準備（テンプレ・測定）

#### 課題0-1: 実装テンプレを作る
**目標**: 以降の課題を素早く回せる雛形を用意する

- `algo/` パッケージ（例: `com.example.algo`）を作り、次を用意：
  - `Main.java`（手動実行用）
  - `Algorithms.java`（staticメソッド集）
  - `Assertions.java`（簡易assert）

**チェックポイント**:
- 小さなテストを頻繁に回せる状態になっているか？

#### 課題0-2: 計測してみる
**目標**: 計算量を「体感」する

- \(n\) を 10^3, 10^4, 10^5 と増やして、線形探索と二分探索の実行時間を比較する
- `System.nanoTime()` を使い、ウォームアップ（数回捨て実行）も入れる

**チェックポイント**:
- \(O(n)\) と \(O(\log n)\) の増え方の違いを言語化できるか？

---

### レベル1: 配列・文字列（最頻パターン）

#### 課題1-1: 二分探索（基本）
**目標**: 境界処理を安定して書けるようにする

- ソート済み配列 `int[] a` から `target` を探してインデックスを返す（なければ `-1`）
- 実装は「左閉右閉」または「左閉右開」を一つに統一して説明できるようにする

**追加**:
- 「最初のtarget」「最後のtarget」（lower/upper bound）も実装する

**チェックポイント**:
- ループ条件と `mid` 計算（オーバーフロー回避）を正しく書けるか？

#### 課題1-2: Two Pointers（ペア探し）
- ソート済み配列で「和がtargetになるペアが存在するか」を `O(n)` で判定する
- 可能なら実際のペアのインデックスも返す

#### 課題1-3: Prefix Sum（区間和）
- `prefix[i+1] = prefix[i] + a[i]` を作り、区間 `[l, r)` の和を `O(1)` で求める
- 2D版（行列の矩形和）もできれば挑戦

#### 課題1-4: 文字列（頻出）
- 文字列を反転（`char[]` で in-place）
- 回文判定（英数字のみ、大小無視の版も）
- 最長共通接頭辞、ランレングス圧縮（RLE）

---

### レベル2: 基本データ構造（スタック/キュー/ヒープ/ハッシュ）

#### 課題2-1: Stack（括弧の整合性）
- `()[]{}` の整合性を判定する
- `Deque<Character>` をスタックとして使う

#### 課題2-2: Queue/BFS（最短手数）
- グリッド（`0/1`）で、開始→終了の最短距離（4近傍）をBFSで求める

#### 課題2-3: Heap（上位K個）
- `int[]` から「上位K個」を `PriorityQueue` で求める
- ついでに「K番目に大きい」を求める

#### 課題2-4: Hash（重複/頻度/最初の一意）
- 文字列の各文字頻度を `Map<Character, Integer>` で数える
- 最初の一意な文字の位置を返す

**チェックポイント**:
- `getOrDefault` / `merge` / `compute` を使い分けられるか？

---

### レベル3: ソート・探索の理解を深める

#### 課題3-1: ソートを自作（学習目的）
- まずは挿入ソート（安定）を実装し、最悪 \(O(n^2)\) を体感する
- 次にマージソート（安定）を実装し、\(O(n\log n)\) を確認する

**チェックポイント**:
- 安定性の意味を「例」で説明できるか？
- マージ時の添字境界がバグらないか？

#### 課題3-2: 二分探索の“単調性”問題
- `x` が大きいほど条件が真になる関数 `ok(x)` を想定して「最小の真」を探す（境界探索）
  - 例: 「容量xの船でD日以内に運べるか？」など

---

### レベル4: グラフ（DFS/BFS）と典型

#### 課題4-1: DFS（連結成分）
- グリッドの島の数（`1`の連結成分数）を数える（DFS/BFSどちらでも）

#### 課題4-2: トポロジカルソート（DAG）
- 有向グラフのトポロジカル順序をKahn法（入次数）で求める

#### 課題4-3: 最短経路（Dijkstra）
- 非負重みグラフで、始点から全点の最短距離を求める
- `PriorityQueue` と距離配列（`long[]`）で実装する

**チェックポイント**:
- 「取り出した時点で最短が確定する」理由を説明できるか？

---

### レベル5: 動的計画法（DP）入門〜中級

#### 課題5-1: 1次元DP（基本）
- フィボナッチ（メモ化→ループ化）
- 最小コスト階段（`dp[i]`）

#### 課題5-2: ナップサックDP（0/1）
- 重さ制限Wで価値最大（2D→1D最適化）

#### 課題5-3: 文字列DP
- 最長増加部分列（LIS: \(O(n\log n)\) 版まで）
- 最長共通部分列（LCS: \(O(nm)\)）

**チェックポイント**:
- 状態（state）・遷移（transition）・初期値（base）を言語化できるか？

---

### レベル6: Greedy（貪欲）の見極め

#### 課題6-1: 区間スケジューリング
- 終了時刻が早い順に選ぶと最大本数になることを、簡単に説明し実装する

#### 課題6-2: 最小コイン（反例も）
- あるコイン体系では貪欲が正しいが、別体系では破綻する例を作る

**チェックポイント**:
- 「なぜ正しいか／どこで破綻するか」を説明できるか？

---

## 📚 学習の進め方（最短で伸びる回し方）

### ステップ1: まず手で追う（5分）
- 小さい入力（3〜7要素）で、変数の変化を紙に書く

### ステップ2: 仕様を固定する（3分）
- 入力の制約（空OK？重複OK？ソート済み？）を明文化
- 戻り値の約束（見つからない時は？）を決める

### ステップ3: 典型パターンに当てはめる（10分）
- Two Pointers / Sliding Window / Prefix Sum / Hash / BFS/DFS / DP / Greedy のどれかを仮決定

### ステップ4: 小テストを先に書く（10分）
- 正常系 + 例外系（境界）を最低5ケース作る

### ステップ5: 実装→リファクタ（20分）
- まず動かす
- その後、変数名・分岐・早期returnを整える

---

## ✅ 理解度の確認方法

以下ができれば「アルゴリズム力」が上がっています：

1. **計算量を見積もれる**
   - 入力制約を見て、狙う計算量を言える（例: \(n=10^5\)なら \(O(n\log n)\) まで、など）

2. **境界条件で落ちない**
   - 空/1要素/重複/オーバーフロー/負数 を自分から試せる

3. **説明できる**
   - なぜ正しいか（不変条件・帰納法・交換法則）を短く説明できる

4. **型（パターン）を言語化できる**
   - 「これは単調性があるから境界二分探索」など

---

## 🎓 次のステップ

このガイドのレベル4〜6まで進めたら：

1. **問題演習の場を決める**
   - AtCoder / LeetCode / Codeforces など（毎日1問で十分）

2. **典型100本を“反復”する**
   - 一度解いた問題を、1週間後に「ノーヒントで」解き直す

3. **実装力を上げる（Java）**
   - 高速I/O（`BufferedInputStream` / `FastScanner`）を用意
   - `StringBuilder`、`Arrays`、`Collections`、`PriorityQueue` を使いこなす

---

頑張ってください！アルゴリズムは「理解→手を動かす→復習」の反復で確実に伸びます。ペースは遅くてOKなので、毎回“境界ケース”だけは必ず潰しましょう。

